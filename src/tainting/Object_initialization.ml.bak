(* Object Initialization Detection for All Languages
 * 
 * This module provides comprehensive object initialization detection
 * for all languages supported by Semgrep, enabling sophisticated
 * taint analysis across object constructors and method calls.
 *)

module G = AST_generic

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

(* Object mapping: variable -> class *)
type object_mapping = G.name * G.name

(* Constructor pattern for a language *)
type constructor_pattern = {
  (* Language-specific pattern matching function *)
  match_pattern : G.expr -> G.name list -> G.name option;
  (* Constructor method names for this language *)
  constructor_names : string list;
  (* Whether the language uses explicit 'new' keyword *)
  uses_new_keyword : bool;
}

(*****************************************************************************)
(* Language-specific Constructor Patterns *)
(*****************************************************************************)

(* Check if a name is in the known classes list *)
let is_known_class (name : G.name) (class_names : G.name list) : bool =
  List.exists (fun class_name ->
    match name, class_name with
    | G.Id ((str1, _), _), G.Id ((str2, _), _) -> str1 = str2
    | _ -> false
  ) class_names

(* Java: new ClassName(args) *)
let java_constructor_pattern : constructor_pattern = {
  match_pattern = (fun rval_expr class_names ->
    match rval_expr.G.e with
    | G.New (_, class_type, _, _) ->
        (match class_type.G.t with
        | G.TyN name when is_known_class name class_names -> Some name
        | _ -> None)
    | _ -> None);
  constructor_names = ["<init>"];
  uses_new_keyword = true;
}

(* C#: new ClassName(args) - similar to Java *)
let csharp_constructor_pattern : constructor_pattern = {
  match_pattern = (fun rval_expr class_names ->
    match rval_expr.G.e with
    | G.New (_, class_type, _, _) ->
        (match class_type.G.t with
        | G.TyN name when is_known_class name class_names -> Some name
        | _ -> None)
    | _ -> None);
  constructor_names = [".ctor"];
  uses_new_keyword = true;
}

(* Kotlin: ClassName(args) or new ClassName(args) *)
let kotlin_constructor_pattern : constructor_pattern = {
  match_pattern = (fun rval_expr class_names ->
    match rval_expr.G.e with
    | G.New (_, class_type, _, _) ->
        (match class_type.G.t with
        | G.TyN name when is_known_class name class_names -> Some name
        | _ -> None)
    | G.Call (class_expr, _) ->
        (match class_expr.G.e with
        | G.N (G.Id ((str, _), _) as name) ->
            if String.length str > 0 && Char.uppercase_ascii str.[0] = str.[0] && is_known_class name class_names
            then Some name 
            else None
        | _ -> None)
    | _ -> None);
  constructor_names = ["<init>"; "init"; "constructor"];
  uses_new_keyword = false; (* Optional in Kotlin *)
}

(* Scala: new ClassName(args) or ClassName(args) *)
let scala_constructor_pattern : constructor_pattern = {
  match_pattern = (fun rval_expr class_names ->
    match rval_expr.G.e with
    | G.New (_, class_type, _, _) ->
        (match class_type.G.t with
        | G.TyN name when is_known_class name class_names -> Some name
        | G.TyExpr expr ->
            (match expr.G.e with
            | G.N (G.Id ((_, _), _) as name) when is_known_class name class_names -> Some name
            | _ -> None)
        | _ -> None)
    | G.Call (class_expr, _) ->
        (match class_expr.G.e with
        | G.N (G.Id ((str, _), _) as name) ->
            if String.length str > 0 && Char.uppercase_ascii str.[0] = str.[0] && is_known_class name class_names
            then Some name 
            else None
        | _ -> None)
    | _ -> None);
  constructor_names = ["<init>"];
  uses_new_keyword = false; (* Optional in Scala *)
}

(* Ruby: ClassName.new(args) *)
let ruby_constructor_pattern : constructor_pattern = {
  match_pattern = (fun rval_expr class_names ->
    match rval_expr.G.e with
    | G.Call (dot_access, _) ->
        (match dot_access.G.e with
        | G.DotAccess (class_expr, _, G.FN (G.Id (("new", _), _))) ->
            (match class_expr.G.e with
            | G.N name when is_known_class name class_names -> Some name
            | _ -> None)
        | _ -> None)
    | _ -> None);
  constructor_names = ["initialize"];
  uses_new_keyword = false;
}

(* Python: ClassName(args) *)
let python_constructor_pattern : constructor_pattern = {
  match_pattern = (fun rval_expr class_names ->
    match rval_expr.G.e with
    | G.Call (class_expr, _) ->
        (match class_expr.G.e with
        | G.N (G.Id ((str, _), _) as name) ->
            if String.length str > 0 && Char.uppercase_ascii str.[0] = str.[0] && is_known_class name class_names
            then Some name 
            else None
        | _ -> None)
    | _ -> None);
  constructor_names = ["__init__"];
  uses_new_keyword = false;
}

(* JavaScript/TypeScript: new ClassName(args) or ClassName() *)
let javascript_constructor_pattern : constructor_pattern = {
  match_pattern = (fun rval_expr class_names ->
    match rval_expr.G.e with
    | G.New (_, class_type, _, _) ->
        (match class_type.G.t with
        | G.TyN name when is_known_class name class_names -> Some name
        | G.TyExpr expr ->
            (match expr.G.e with
            | G.N (G.Id ((_, _), _) as name) when is_known_class name class_names -> Some name
            | _ -> None)
        | _ -> None)
    | G.Call (class_expr, _) ->
        (match class_expr.G.e with
        | G.N (G.Id ((str, _), _) as name) ->
            if String.length str > 0 && Char.uppercase_ascii str.[0] = str.[0] && is_known_class name class_names
            then Some name 
            else None
        | _ -> None)
    | _ -> None);
  constructor_names = ["constructor"];
  uses_new_keyword = true; (* Preferred *)
}

(* Swift: ClassName(args) *)
let swift_constructor_pattern : constructor_pattern = {
  match_pattern = (fun rval_expr class_names ->
    match rval_expr.G.e with
    | G.Call (class_expr, _) ->
        (match class_expr.G.e with
        | G.N (G.Id ((str, _), _) as name) ->
            if String.length str > 0 && Char.uppercase_ascii str.[0] = str.[0] && is_known_class name class_names
            then Some name 
            else None
        | _ -> None)
    | _ -> None);
  constructor_names = ["init"];
  uses_new_keyword = false;
}

(* Go: Go struct initialization patterns *)
let go_constructor_pattern : constructor_pattern = {
  match_pattern = (fun rval_expr class_names ->
    Printf.eprintf "[Go Constructor Debug] Checking rval_expr pattern\n%!";
    match rval_expr.G.e with
    (* Handle &StructName{field: value} - Go reference to struct literal *)
    | G.Ref (_, struct_expr) ->
        Printf.eprintf "[Go Constructor Debug] Found Ref pattern\n%!";
        (match struct_expr.G.e with
        | G.New (_, struct_type, _, (_, args, _)) ->
            Printf.eprintf "[Go Constructor Debug] Found New inside Ref with %d args\n%!" (List.length args);
            (match struct_type.G.t with
            | G.TyN name when is_known_class name class_names -> 
                Printf.eprintf "[Go Constructor Debug] Matched Go struct type in Ref\n%!";
                Some name
            | _ -> 
                Printf.eprintf "[Go Constructor Debug] Go struct type not in known classes\n%!";
                None)
        | _ -> 
            Printf.eprintf "[Go Constructor Debug] Not New inside Ref\n%!";
            None)
    (* Handle direct StructName{} - Go struct literal *)
    | G.New (_, struct_type, _, _) ->
        Printf.eprintf "[Go Constructor Debug] Found direct New pattern\n%!";
        (match struct_type.G.t with
        | G.TyN name when is_known_class name class_names -> 
            Printf.eprintf "[Go Constructor Debug] Matched Go struct type in direct New\n%!";
            Some name
        | _ -> 
            Printf.eprintf "[Go Constructor Debug] Go struct type not in known classes\n%!";
            None)
    | _ -> 
        Printf.eprintf "[Go Constructor Debug] No matching pattern\n%!";
        None);
  constructor_names = []; (* Go uses struct literals, no named constructors *)
  uses_new_keyword = false;
}

(* Rust: Rust object initialization patterns - simplified for now *)
let rust_constructor_pattern : constructor_pattern = {
  match_pattern = (fun rval_expr class_names ->
    match rval_expr.G.e with
    | G.Call (dot_access, _) ->
        (match dot_access.G.e with
        | G.DotAccess (class_expr, _, G.FN (G.Id (("new", _), _))) ->
            (match class_expr.G.e with
            | G.N name when is_known_class name class_names -> Some name
            | _ -> None)
        | _ -> None)
    | _ -> None);
  constructor_names = ["new"];
  uses_new_keyword = false;
}

(* Dart: new ClassName(args) or ClassName(args) *)
let dart_constructor_pattern : constructor_pattern = {
  match_pattern = (fun rval_expr class_names ->
    match rval_expr.G.e with
    | G.New (_, class_type, _, _) ->
        (match class_type.G.t with
        | G.TyN name when is_known_class name class_names -> Some name
        | G.TyExpr expr ->
            (match expr.G.e with
            | G.N (G.Id ((_, _), _) as name) when is_known_class name class_names -> Some name
            | _ -> None)
        | _ -> None)
    | G.Call (class_expr, _) ->
        (match class_expr.G.e with
        | G.N (G.Id ((str, _), _) as name) ->
            if String.length str > 0 && Char.uppercase_ascii str.[0] = str.[0] && is_known_class name class_names
            then Some name 
            else None
        | _ -> None)
    | _ -> None);
  constructor_names = ["constructor"];
  uses_new_keyword = false; (* Optional in modern Dart *)
}

(* PHP: new ClassName(args) *)
let php_constructor_pattern : constructor_pattern = {
  match_pattern = (fun rval_expr class_names ->
    match rval_expr.G.e with
    | G.New (_, class_type, _, _) ->
        (match class_type.G.t with
        | G.TyN name when is_known_class name class_names -> Some name
        | G.TyExpr expr ->
            (match expr.G.e with
            | G.N (G.Id ((_, _), _) as name) when is_known_class name class_names -> Some name
            | _ -> None)
        | _ -> None)
    | _ -> None);
  constructor_names = ["__construct"];
  uses_new_keyword = true;
}

(*****************************************************************************)
(* Language Pattern Mapping *)
(*****************************************************************************)

let get_constructor_pattern (lang : Lang.t) : constructor_pattern option =
  match lang with
  | Lang.Java -> Some java_constructor_pattern
  | Lang.Csharp -> Some csharp_constructor_pattern
  | Lang.Kotlin -> Some kotlin_constructor_pattern
  | Lang.Scala -> Some scala_constructor_pattern
  | Lang.Ruby -> Some ruby_constructor_pattern
  | Lang.Python | Lang.Python2 | Lang.Python3 -> Some python_constructor_pattern
  | Lang.Js | Lang.Ts -> Some javascript_constructor_pattern
  | Lang.Swift -> Some swift_constructor_pattern
  | Lang.Go -> Some go_constructor_pattern
  | Lang.Rust -> Some rust_constructor_pattern
  | Lang.Dart -> Some dart_constructor_pattern
  | Lang.Php -> Some php_constructor_pattern
  | _ -> None (* Unsupported language *)

(*****************************************************************************)
(* Class Detection *)
(*****************************************************************************)

(* Collect all class names from the AST *)
let collect_class_names (ast : G.program) : G.name list =
  let class_names = ref [] in
  let visitor = object
    inherit [_] G.iter as super
    
    method! visit_definition () def =
      (match def with
      | (entity, G.ClassDef _) ->
          (match entity.G.name with
          | G.EN name -> 
              let name_str = match name with
                | G.Id ((str, _), _) -> str
                | _ -> "???"
              in
              Printf.eprintf "[Go Debug] Found class: %s\n%!" name_str;
              class_names := name :: !class_names
          | _ -> ())
      (* Handle Go struct definitions - TypeDef with TyRecordAnon *)
      | (entity, G.TypeDef type_def) ->
          (match entity.G.name, type_def.G.tbody with
          | G.EN name, G.NewType { G.t = G.TyRecordAnon ((G.Class, _), _); _ } -> 
              let name_str = match name with
                | G.Id ((str, _), _) -> str
                | _ -> "???"
              in
              Printf.eprintf "[Go Debug] Found Go struct: %s\n%!" name_str;
              class_names := name :: !class_names
          | _ -> ())
      | _ -> ());
      super#visit_definition () def
  end in
  
  List.iter (fun item ->
    match item.G.s with
    | G.DefStmt def ->
        visitor#visit_definition () def
    | _ -> ()
  ) ast;
  !class_names

(*****************************************************************************)
(* Object Initialization Detection *)
(*****************************************************************************)

(* Extract class name from constructor call expression *)
let extract_class_name_from_constructor (rval_expr : G.expr) (lang : Lang.t) (class_names : G.name list) : G.name option =
  match get_constructor_pattern lang with
  | Some pattern -> pattern.match_pattern rval_expr class_names
  | None -> None

(* Object initialization detection for different languages *)
let detect_object_initialization (ast : G.program) (lang : Lang.t) : object_mapping list =
  Printf.eprintf "[Object Init Debug] Starting object initialization detection for language: %s\n%!" (Lang.to_string lang);
  let class_names = collect_class_names ast in
  Printf.eprintf "[Object Init Debug] Found %d class names\n%!" (List.length class_names);
  let object_mappings = ref [] in
  
  let visitor = object
    inherit [_] G.iter as super
    
    method! visit_stmt () stmt =
      (match stmt.G.s with
      | G.ExprStmt (expr, _) ->
          (* Look for assignment patterns *)
          (match expr.G.e with
          | G.Assign (lval_expr, _, rval_expr) ->
              Printf.eprintf "[Object Init Debug] Found G.Assign pattern\n%!";
              (* Extract variable name from left side *)
              let var_name = match lval_expr.G.e with
                | G.N name -> Some name
                (* Handle Go struct field assignments: user.name = ... *)
                | G.DotAccess (obj_expr, _, G.FN _) when lang = Lang.Go ->
                    Printf.eprintf "[Go Field Debug] Found DotAccess pattern in Go\n%!";
                    (match obj_expr.G.e with
                    | G.N obj_name ->
                        Printf.eprintf "[Go Field Debug] Found object name in DotAccess\n%!";
                        (* Check if this object is already mapped to a struct *)
                        let existing_mapping = List.find_opt (fun (var, _) ->
                          match var, obj_name with
                          | G.Id ((str1, _), _), G.Id ((str2, _), _) -> str1 = str2
                          | _ -> false
                        ) !object_mappings in
                        (match existing_mapping with
                        | Some (_, _) ->
                            Printf.eprintf "[Go Field Debug] Object already mapped, skipping\n%!";
                            (* We already know this object maps to a struct, no need to re-add *)
                            None
                        | None -> 
                            Printf.eprintf "[Go Field Debug] Object not yet mapped, adding\n%!";
                            Some obj_name) (* New object, extract name *)
                    | _ -> 
                        Printf.eprintf "[Go Field Debug] No object name found in DotAccess\n%!";
                        None)
                | _ -> None
              in
              (* Extract class name from right side *)
              let class_name = extract_class_name_from_constructor rval_expr lang class_names in
              (* Add mapping if both var and class found *)
              (match var_name, class_name with
              | Some var, Some cls -> object_mappings := (var, cls) :: !object_mappings
              | _ -> ())
          | G.AssignOp (lval_expr, _, rval_expr) ->
              Printf.eprintf "[Object Init Debug] Found G.AssignOp pattern (Go :=)\n%!";
              (* Extract variable name from left side *)
              let var_name = match lval_expr.G.e with
                | G.N name -> Some name
                | _ -> None
              in
              (* Extract class name from right side *)
              let class_name = extract_class_name_from_constructor rval_expr lang class_names in
              (* Add mapping if both var and class found *)
              (match var_name, class_name with
              | Some var, Some cls -> object_mappings := (var, cls) :: !object_mappings
              | _ -> ())
          | _ -> ())
      | _ -> ());
      super#visit_stmt () stmt
    
    method! visit_definition () def =
      (match def with
      | (entity, G.VarDef var_def) ->
          (* Handle variable declarations with initialization *)
          (match entity.G.name, var_def.G.vinit with
          | G.EN var_name, Some init_expr ->
              let class_name = extract_class_name_from_constructor init_expr lang class_names in
              (match class_name with
              | Some cls -> object_mappings := (var_name, cls) :: !object_mappings
              | _ -> ())
          | _ -> ())
      | _ -> ());
      super#visit_definition () def
  end in
  
  (* Visit all statements in the program *)
  visitor#visit_program () ast;
  Printf.eprintf "[Object Init Debug] Final object mappings count: %d\n%!" (List.length !object_mappings);
  List.iteri (fun i (var, cls) ->
    let var_str = match var with G.Id ((str, _), _) -> str | _ -> "???" in
    let cls_str = match cls with G.Id ((str, _), _) -> str | _ -> "???" in
    Printf.eprintf "[Object Init Debug] Mapping %d: %s -> %s\n%!" i var_str cls_str
  ) !object_mappings;
  !object_mappings

(*****************************************************************************)
(* Constructor Detection Utilities *)
(*****************************************************************************)

(* Check if a function is a constructor for the given language *)
let is_constructor (lang : Lang.t) (func_name : string) (class_name_opt : string option) : bool =
  match get_constructor_pattern lang with
  | Some pattern ->
      List.mem func_name pattern.constructor_names ||
      (match class_name_opt with
      | Some class_name -> func_name = class_name (* Java/C#/etc. constructor has same name as class *)
      | None -> false)
  | None -> false

(* Get all constructor method names for a language *)
let get_constructor_names (lang : Lang.t) : string list =
  match get_constructor_pattern lang with
  | Some pattern -> pattern.constructor_names
  | None -> []

(* Check if language uses 'new' keyword *)
let uses_new_keyword (lang : Lang.t) : bool =
  match get_constructor_pattern lang with
  | Some pattern -> pattern.uses_new_keyword
  | None -> false

(*****************************************************************************)
(* Debugging and Display *)
(*****************************************************************************)

let show_object_mapping (var_name, class_name) =
  let var_str = match var_name with
    | G.Id ((str, _), _) -> str
    | _ -> "???"
  in
  let class_str = match class_name with
    | G.Id ((str, _), _) -> str
    | _ -> "???"
  in
  Printf.sprintf "%s -> %s" var_str class_str

let show_object_mappings (mappings : object_mapping list) =
  mappings
  |> List.map show_object_mapping
  |> String.concat "; "
  |> Printf.sprintf "[%s]"